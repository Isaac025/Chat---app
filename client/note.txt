** onclick{() => window.open(url)}
selectedUser(user)
w-[min(30vw,250px)]


----- This function fetches all users except the logged-in user and also counts how many unread (unseen) messages each user has sent to the logged-in user.
It is typically used for a chat app sidebar. ------

** const MESSAGE = require("../models/message");
Imports the Message Mongoose model
Used to interact with the messages collection in MongoDB
Allows querying messages (read/unread, sender, receiver, etc.)

const userId = req.user._id;
req.user comes from authentication middleware
_id is the logged-in userâ€™s MongoDB ID
Used to:
Exclude the user from the user list
Find messages sent to this user

const filteredUsers = await USER.find({ _id: { $ne: userId } }).select(
  "-password"
); // fetch all users except logged in users

USER.find() â†’ fetches users from database
{ _id: { $ne: userId } }

$ne = not equal
Excludes the logged-in user

.select("-password")
Removes password field for security
Result:
A list of all users except the current user, without passwords.

const unseenMessages = {}; // create object to store unseen message counts
{
  userId1: 3,
  userId2: 7
} // structure of unseen message

** Loop Through Each User
const promises = filteredUsers.map(async (user) => {

})
Loops over every user in filteredUsers
Uses map() with async function
Returns an array of promises

const messages = await MESSAGE.find({
  senderId: user._id,
  receiverId: userId,
  seen: false,
}); //Find Unseen Messages for Each User


This query finds:

Messages:

Sent from this user
Sent to the logged-in user
That are not seen
Used to calculate unread message count

Find messages sent by this user, to me, that I havenâ€™t seen yet.â€

ðŸ“Œ Very important logic:

senderId: user._id â†’ they sent it
receiverId: userId â†’ I received it
seen: false â†’ unread messages

if (messages.length > 0) {
  unseenMessages[user._id] = messages.length;
} //Store Count If Messages Exist

- Check if there are any messages:
messages.length > 0 evaluates whether the messages array contains at least one item. If there are no messages, the code inside the if block is skipped.
- Access the userâ€™s unique identifier:
user._id retrieves the current userâ€™s ID. This is used as a dynamic key in the unseenMessages object.
- Store the count of messages under that userâ€™s ID:
unseenMessages[user._id] = messages.length; assigns the number of messages to the object entry keyed by the userâ€™s ID. If the key already exists, it updates the value; if not, it creates a new key-value pair.

await Promise.all(promises);
Ensures all message-count queries finish before responding
Prevents incomplete data being sent to client

The receiverId is being used â€” just not directly in the count.
It is used as a filter condition to make sure we only count messages sent to the logged-in user.

Without receiverId, you would also count:

Messages the logged-in user sent to others

Messages between two other users

Messages sent to a different user

âŒ That would be wrong for a sidebar unread count.

user._id changes on every loop iteration
This represents each other user in the system
So inside the loop:
senderId: user._id â†’ messages from that user
receiverId: userId â†’ messages to me
seen: false â†’ messages I havenâ€™t read
âœ… Together, these conditions isolate exactly the messages you care about.


selectedUserId comes from req.params because it was sent by the frontend in the URL

user._id comes from filteredUsers because it was read from the database

They come from two different sources:

ðŸ”µ req.params â†’ client (frontend)

ðŸŸ¢ user._id â†’ database (backend)

const getMessages = async (req, res) => {
Fetches all messages between:
Logged-in user
Selected user

Extract IDs
const { id: selectedUserId } = req.params;
const myId = req.user._id;
selectedUserId â†’ user you clicked on
myId â†’ logged-in user

const messages = await MESSAGE.find({
  $or: [
    { senderId: myId, receiverId: selectedUserId },
    { senderId: selectedUserId, receiverId: myId },
  ],
});
Meaning: â€œGive me all messages exchanged between us, regardless of who sent them.â€
await MESSAGE.updateMany(
  { senderId: selectedUserId, receiverId: myId },
  { seen: true }
);
Updates messages: Sent by them, Received by me, Marks them as read
This is what clears notification badges

// we want this message to be displayed in real time

**Why Socket.IO needs an HTTP server**
Socket.IO: Does NOT attach directly to Express
Attaches to the HTTP server

Client
  â†“
HTTP Server (Node)
  â†“
Express (REST)
  â†“
Socket.IO (WebSockets)

const io = new Server(server, {
  cors: { origin: "*" },
});
io = global socket server
Listens for: New connections, Broadcasts, Rooms, Events
Think of io as: â€œThe manager of all real-time connectionsâ€

const userSocketMap = {}; // { userId: socketId }
Tracking online users (IMPORTANT)
Maps users â†’ their socket connections

{
  "64ab1": "socket123",
  "64ab2": "socket456"
}
-- send private messages
-- track online users 
-- Emit to a specific user

** HANDLING NEW CONNECTIONS
io.on("connection", (socket) => {
Every time a user connects
Every browser tab gets its own socket
socket = one connected client

const userId = socket.handshake.query.userId; // getting userId from frontend

if (userId) {
    userSocketMap[userId] = socket.id; // â€œThis user is online, and this is their socket.â€
  }

socket.on("disconnect", () => {
Runs when: User closes tab, Internet drops, App closes

socket.on("disconnect", () => {
    console.log("User Disconnected", userId);
    delete userSocketMap[userId]; // Remove user from online list
    // Emit online users to all connected clients
    io.emit("getOnlineUsers", Object.keys(userSocketMap)); // Re-broadcast updated online users
  });

| REST (Express)     | Socket.IO               |
| ------------------ | ----------------------- |
| Save messages      | Send messages instantly |
| Fetch chat history | Real-time delivery      |
| Authentication     | Presence & typing       |
| Database logic     | UI updates              |

Typical flow:

REST â†’ save message
Socket.IO â†’ emit message to receiver
Frontend updates instantly

Express handles data. Socket.IO handles time.

HTTP server = base
Express = API
Socket.IO = real-time layer
io = global broadcaster
socket = one user
userSocketMap = online presence system

CORS (Cross-Origin Resource Sharing)

Important concept: Socket.IO does NOT use Express middleware
so this: app.use(cors()); does not affect sockets 
Thatâ€™s why Socket.IO has its own CORS config.

Safe for development
Restrict in production

do this for production 
cors: {
  origin: process.env.CLIENT_URL,
  methods: ["GET", "POST"],
}

